"use strict";(self.webpackChunktokamak_docs=self.webpackChunktokamak_docs||[]).push([[19],{1799:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return l},default:function(){return d}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o={sidebar_position:3},s="Providers",p={unversionedId:"getting-started/providers",id:"getting-started/providers",isDocsHomePage:!1,title:"Providers",description:"Providers are the fundamental building block in TokamakJS. You can think of a provider as a self contained piece of business logic that can be used by other parts of the application in a clear and declarative way. Providers come in all sort of different shapes, anything that is not a controller or a view is gonna be a provider in one way or another. However, most of the time a provider is just a class annotated with either @Injectable() or @HookService().",source:"@site/docs/getting-started/providers.md",sourceDirName:"getting-started",slug:"/getting-started/providers",permalink:"/tokamakjs/docs/getting-started/providers",editUrl:"https://github.com/tokamakjs/tokamak-docs/edit/master/docs/getting-started/providers.md",version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Routing and Routes",permalink:"/tokamakjs/docs/getting-started/routing"}},l=[{value:"Injectables",id:"injectables",children:[]},{value:"Hook services",id:"hook-services",children:[]},{value:"Custom providers",id:"custom-providers",children:[]},{value:"Adding providers to the app",id:"adding-providers-to-the-app",children:[]}],c={toc:l};function d(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"providers"},"Providers"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Providers")," are the fundamental building block in ",(0,i.kt)("strong",{parentName:"p"},"TokamakJS"),". You can think of a provider as a self contained piece of business logic that can be used by other parts of the application in a clear and declarative way. Providers come in all sort of different shapes, anything that is not a ",(0,i.kt)("strong",{parentName:"p"},"controller")," or a ",(0,i.kt)("strong",{parentName:"p"},"view")," is gonna be a ",(0,i.kt)("strong",{parentName:"p"},"provider")," in one way or another. However, most of the time a provider is just a class annotated with either ",(0,i.kt)("inlineCode",{parentName:"p"},"@Injectable()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"@HookService()"),"."),(0,i.kt)("p",null,"The main idea behind a provider is that they can be injected as dependencies into other components of the application leaving all the class instantiation and wiring to the ",(0,i.kt)("strong",{parentName:"p"},"TokamakJS")," runtime. This is achieved using a technique called ",(0,i.kt)("a",{parentName:"p",href:"https://wiki2.org/en/Dependency_injection"},"dependency injection"),"."),(0,i.kt)("h2",{id:"injectables"},"Injectables"),(0,i.kt)("p",null,"The simplest way of creating a provider is decorating a plain class with the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Injectable()")," decorator. This marks the class as ready to be injected as dependency into other providers or controllers."),(0,i.kt)("p",null,"Services and API classes are good candidates to be injected this way since they should not interact with React logic and usually are instantiated once when starting up the application and then, re-used."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Injectable } from '@tokamakjs/react';\n\n@Injectable()\nexport class CounterApi {\n  public async saveValue(value: number): Promise<void> {\n    // implementation...\n  }\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Injectable } from '@tokamakjs/react';\n\nimport { CounterApi } from '../api';\n\n@Injectable()\nexport class CounterService {\n  // CounterApi will be injected automatically\n  constructor(private readonly _api: CounterApi) {}\n\n  public async saveValue(value: number): Promise<void> {\n    // implementation...\n  }\n}\n")),(0,i.kt)("p",null,"By default, classes decorated with ",(0,i.kt)("inlineCode",{parentName:"p"},"@Injectable()")," are instantiated as ",(0,i.kt)("a",{parentName:"p",href:"https://wiki2.org/en/Singleton_pattern"},"singletons"),". It's possible however to change this behavior by setting a different ",(0,i.kt)("inlineCode",{parentName:"p"},"scope")," when decorating the class. E.g."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Injectable, Scope } from '@tokamakjs/react';\n\n@Injectable({ scope: Scope.TRANSIENT })\nexport class CounterApi {\n  public async saveValue(value: number): Promise<void> {\n    // implementation...\n  }\n}\n")),(0,i.kt)("p",null,"There are two possible values for ",(0,i.kt)("inlineCode",{parentName:"p"},"scope"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Scope.TRANSIENT"),": A new instance will be created every time the provider is injected as a dependency."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Scope.SINGLETON")," ",(0,i.kt)("em",{parentName:"li"},"(default)"),": An instance will be created at startup and re-used every time the provider is injected as a dependency.")),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"If you used the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/tokamakjs/cli"},"CLI")," to bootstrap your project, you can easily create an API class using ",(0,i.kt)("inlineCode",{parentName:"p"},"npx tok generate api [ClassName]"),". In the same way, you can create services as well using ",(0,i.kt)("inlineCode",{parentName:"p"},"npx tok generate service [ClassName]"),"."))),(0,i.kt)("p",null,"To be able to use the created providers in the application, don't forget to add them to the ",(0,i.kt)("inlineCode",{parentName:"p"},"providers")," array in either ",(0,i.kt)("inlineCode",{parentName:"p"},"@Module()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"@SubApp()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { SubApp } from '@tokmamakjs/react';\n\nimport { CounterController } from './routes/counter';\nimport { CounterApi } from './api';\nimport { CounterService } from './services';\n\n@SubApp({\n  routing: [createRoute('/', CounterController)],\n  providers: [CounterApi, CounterService],\n})\nexport class AppModule {}\n")),(0,i.kt)("p",null,"After the providers have been added to the ",(0,i.kt)("inlineCode",{parentName:"p"},"@SubClass()")," we can use them in our controllers (or in others providers as shown above) simply by declaring them as dependencies in the ",(0,i.kt)("inlineCode",{parentName:"p"},"constructor()"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Controller, state, effect } from '@tokamakjs/react';\n\nimport { CounterService } from '../../services';\nimport { CounterView } from './counter.view';\n\n@Controller({ view: CounterView })\nexport class CounterController {\n  @state private readonly _value = 0;\n\n  get value() {\n    return this._value;\n  }\n\n  // CounterService is injected automatically\n  constructor(private readonly _counterService: CounterService) {}\n\n  // Track and save value every time it changes)\n  @effect((self: CounterController) => [self.value]))\n  protected async saveValue(): Promise<void> {\n    // We can use the injected provider like any other property\n    await this._counterService.saveValue(this._value);\n  }\n\n  public increase(): void {\n    this._value += 1;\n  }\n}\n")),(0,i.kt)("h2",{id:"hook-services"},"Hook services"),(0,i.kt)("h2",{id:"custom-providers"},"Custom providers"),(0,i.kt)("h2",{id:"adding-providers-to-the-app"},"Adding providers to the app"))}d.isMDXComponent=!0}}]);