"use strict";(self.webpackChunktokamak_docs=self.webpackChunktokamak_docs||[]).push([[902],{9164:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return d},default:function(){return p}});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),i={sidebar_position:2},s="Routing and Routes",l={unversionedId:"getting-started/routing",id:"getting-started/routing",isDocsHomePage:!1,title:"Routing and Routes",description:"A route in TokamakJS is comprised of a view and a controller. Each view in TokamakJS is 1:1 mapped to a controller meaning that each controller can only be used in their corresponding view and viceversa.",source:"@site/docs/getting-started/routing.md",sourceDirName:"getting-started",slug:"/getting-started/routing",permalink:"/tokamakjs/docs/getting-started/routing",editUrl:"https://github.com/tokamakjs/tokamak-docs/edit/master/docs/getting-started/routing.md",version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Project",permalink:"/tokamakjs/docs/getting-started/project"},next:{title:"Providers",permalink:"/tokamakjs/docs/getting-started/providers"}},d=[{value:"Views",id:"views",children:[]},{value:"Controllers",id:"controllers",children:[]},{value:"Using data",id:"using-data",children:[]},{value:"Reacting to the life-cycle",id:"reacting-to-the-life-cycle",children:[{value:"Mount and unmount step",id:"mount-and-unmount-step",children:[]},{value:"Render step",id:"render-step",children:[]}]},{value:"Tracking Property Values",id:"tracking-property-values",children:[]},{value:"Using Routes",id:"using-routes",children:[]}],c={toc:d};function p(e){var t=e.components,n=(0,o.Z)(e,["components"]);return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"routing-and-routes"},"Routing and Routes"),(0,a.kt)("p",null,"A route in ",(0,a.kt)("strong",{parentName:"p"},"TokamakJS")," is comprised of a ",(0,a.kt)("strong",{parentName:"p"},"view")," and a ",(0,a.kt)("strong",{parentName:"p"},"controller"),". Each view in ",(0,a.kt)("strong",{parentName:"p"},"TokamakJS")," is 1:1 mapped to a controller meaning that each controller can only be used in their corresponding view and viceversa."),(0,a.kt)("p",null,"Finally, each route will have an associated path that will map the controller to the corresponding browser url."),(0,a.kt)("h2",{id:"views"},"Views"),(0,a.kt)("p",null,"Views are just regular React components that have a specific controller associated to them. Together with this controller, they compose a route in ",(0,a.kt)("strong",{parentName:"p"},"TokamakJS"),"."),(0,a.kt)("p",null,"// TODO"),(0,a.kt)("h2",{id:"controllers"},"Controllers"),(0,a.kt)("p",null,"Controllers are the main link between the view layer and the rest of the application. For that, they sit in a blurry line between what is considered application/business logic and what is considered view logic."),(0,a.kt)("p",null,"They take care of providing their views with the required data, perform any required initialization steps and react to events triggered by the view. Everything that is not strictly view logic, goes in a controller."),(0,a.kt)("p",null,"To create a controller, decorate a class with the ",(0,a.kt)("inlineCode",{parentName:"p"},"@Controller")," decorator. E.g."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Controller } from '@tokamakjs/react';\n\nimport { CounterView } from './counter.view';\n\n@Controller({ view: CounterView })\nclass CounterController {}\n")),(0,a.kt)("h2",{id:"using-data"},"Using data"),(0,a.kt)("p",null,"You can store and manipulate data inside controllers by using the ",(0,a.kt)("inlineCode",{parentName:"p"},"@state")," decorator."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Controller, state } from '@tokamakjs/react';\n\nimport { CounterView } from './counter.view';\n\n@Controller({ view: CounterView })\nclass CounterController {\n  @state private _counter = 0;\n\n  public increase(): void {\n    this._counter += 1;\n  }\n\n  public decrease(): void {\n    this._counter -= 1;\n  }\n}\n")),(0,a.kt)("p",null,"Any change to a property decorated this way will trigger a re-render of the associated view. It's very similar to the ",(0,a.kt)("inlineCode",{parentName:"p"},"useState()")," hook in React."),(0,a.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"You should treat the data stored using ",(0,a.kt)("inlineCode",{parentName:"p"},"@state")," as immutable. ",(0,a.kt)("strong",{parentName:"p"},"TokamakJS")," will only react to new assignments to properties tracked this way and any change made to the stored data itself (for example, mutating an object's property) will not trigger a re-render of the view."))),(0,a.kt)("p",null,"Additionally, in case you want to store data between re-renders but don't want to re-render the view every time the data is modified, a ",(0,a.kt)("inlineCode",{parentName:"p"},"@ref")," decorator similar to the ",(0,a.kt)("inlineCode",{parentName:"p"},"useRef()")," hook from React is provided. E.g."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Controller, ref } from '@tokamakjs/react';\n\nimport { CounterView } from './counter.view';\n\n@Controller({ view: CounterView })\nclass CounterController {\n  @ref private _counter = 0;\n\n  public increase(): void {\n    // this will not trigger a re-render as the property is decorated with @ref\n    this._counter += 1;\n  }\n}\n")),(0,a.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"Any property not decorated with either ",(0,a.kt)("inlineCode",{parentName:"p"},"@state")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"@ref")," will have their values re-initialized every time the view re-renders."))),(0,a.kt)("h2",{id:"reacting-to-the-life-cycle"},"Reacting to the life-cycle"),(0,a.kt)("h3",{id:"mount-and-unmount-step"},"Mount and unmount step"),(0,a.kt)("p",null,"In case certain methods need to run when first mounting the view, an ",(0,a.kt)("inlineCode",{parentName:"p"},"onDidMount()")," decorator is available. This decorator, very similar to the ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect()")," hook from React when using an empty array as dependencies, will make any decorated method run when the view is rendered for the first time."),(0,a.kt)("p",null,"Similarly to the mentioned ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect()")," hook, methods decorated with ",(0,a.kt)("inlineCode",{parentName:"p"},"onDidMount()")," can return a callback function that will run when the component is unmounted."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Controller, onDidMount } from '@tokamakjs/react';\n\nimport { CounterView } from './counter.view';\n\n@Controller({ view: CounterView })\nclass CounterController {\n\n  @onDidMount()\n  protected didMount(): void {\n    // this will run when the view is rendered for the first time\n  }\n\n  @onDidMount()\n  protected anotherDidMount(): Function {\n    // this will also run when the view is rendered for the first time\n\n    return () => {\n      // this runs when the component is going to be unmounted\n    };\n  }\n\n}\n")),(0,a.kt)("h3",{id:"render-step"},"Render step"),(0,a.kt)("p",null,"Very similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"onDidMount()")," we have the ",(0,a.kt)("inlineCode",{parentName:"p"},"onDidRender()")," decorator to run a method every time the view is re-rendered. This decorator also supports returning a void function to be run before the view is re-rendered."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Controller, onDidRender } from '@tokamakjs/react';\n\nimport { CounterView } from './counter.view';\n\n@Controller({ view: CounterView })\nclass CounterController {\n\n  @onDidRender()\n  protected didMount(): void {\n    // this will run every time the view is re-rendered\n  }\n\n  @onDidRender()\n  protected anotherDidMount(): Function {\n    // this will also run every time the view is re-rendered\n\n    return () => {\n      // this will run every time before the view is re-rendered\n    };\n  }\n\n}\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"onDidRender()")," decorator can be compared to using the ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect()")," hook without providing an array of dependencies."),(0,a.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"An execution order is not guaranteed when having multiple methods decorated with the life-cycle decorators so don't make any assumptions based on it."))),(0,a.kt)("h2",{id:"tracking-property-values"},"Tracking Property Values"),(0,a.kt)("p",null,"It's possible to track changes to properties using the ",(0,a.kt)("inlineCode",{parentName:"p"},"@effect()")," decorator."),(0,a.kt)("p",null,"// TODO"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Controller, effect } from '@tokamakjs/react';\n\nimport { CounterView } from './counter.view';\n\n@Controller({ view: CounterView })\nclass CounterController {\n  @state private _trackedCounter = 0;\n  @state private _counter = 0;\n\n  @effect((self: CounterController) => [self._trackedCounter])\n  protected reactToTrackedCounter(): void {\n    // this will run every time _trackedCounter changes. However, any\n    // changes to _counter will not have any effects.\n  }\n}\n")),(0,a.kt)("h2",{id:"using-routes"},"Using Routes"),(0,a.kt)("p",null,"// TODO"),(0,a.kt)("p",null,"Add them to ",(0,a.kt)("inlineCode",{parentName:"p"},"routing")," in subapps and use ",(0,a.kt)("inlineCode",{parentName:"p"},"createRoute")))}p.isMDXComponent=!0}}]);